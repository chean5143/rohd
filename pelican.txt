/**
 * Generated by ROHD - www.github.com/intel/rohd
 * Generation time: 2023-03-28 08:08:34.997 +08:00
 * ROHD Version: 0.4.2
 */

module FRTimer(
input logic reset,
input logic clk,
output logic fr
);
logic [2:0] q;
assign fr = q == 3'h5;  // equals
//  sequential
always_ff @(posedge clk) begin
  if((reset | (q == 3'h5))) begin
      q <= 3'h0;
  end   else begin
      q <= (q + 3'h1);
  end 

end

endmodule : FRTimer

////////////////////

module Timer(
input logic start,
input logic clk,
output logic st,
output logic mt,
output logic lt
);
logic [7:0] q;
assign st = q == 8'h32;  // equals
//  sequential
always_ff @(posedge clk) begin
  if(((~start) | (q == 8'hc8))) begin
      q <= 8'h0;
  end   else begin
      q <= (q + 8'h1);
  end 

end

assign lt = q == 8'hc8;  // equals_1
assign mt = q == 8'h50;  // equals_2
endmodule : Timer

////////////////////

module Pelcont(
input logic clock,
input logic reset,
input logic ped,
input logic st_wire,
input logic mt_wire,
input logic lt_wire,
input logic fl_wire,
output logic red,
output logic amber,
output logic green,
output logic entimer
);
logic [2:0] currentState;
logic [2:0] nextState;
//  combinational
always_comb begin
  unique case (currentState) 
      3'h0 : begin
          red = 1'h0;
          amber = 1'h1;
          green = 1'h1;
          entimer = 1'h0;
          unique case (1'h1) 
              1'h1 : begin
                  nextState = 3'h1;
              end
              default : begin
                  nextState = currentState;
              end
          endcase

      end
      3'h1 : begin
          red = 1'h0;
          amber = 1'h1;
          green = 1'h1;
          entimer = 1'h1;
          unique case (1'h1) 
              lt_wire : begin
                  nextState = 3'h2;
              end
              (~lt_wire) : begin
                  nextState = 3'h1;
              end
              default : begin
                  nextState = currentState;
              end
          endcase

      end
      3'h2 : begin
          red = 1'h1;
          amber = 1'h0;
          green = 1'h1;
          entimer = 1'h0;
          unique case (1'h1) 
              1'h1 : begin
                  nextState = 3'h3;
              end
              default : begin
                  nextState = currentState;
              end
          endcase

      end
      3'h3 : begin
          red = 1'h1;
          amber = 1'h0;
          green = 1'h1;
          entimer = 1'h1;
          unique case (1'h1) 
              mt_wire : begin
                  nextState = 3'h5;
              end
              ((~mt_wire) & fl_wire) : begin
                  nextState = 3'h4;
              end
              ((~mt_wire) & (~fl_wire)) : begin
                  nextState = 3'h3;
              end
              default : begin
                  nextState = currentState;
              end
          endcase

      end
      3'h4 : begin
          red = 1'h1;
          amber = 1'h1;
          green = 1'h1;
          entimer = 1'h1;
          unique case (1'h1) 
              mt_wire : begin
                  nextState = 3'h5;
              end
              ((~mt_wire) & fl_wire) : begin
                  nextState = 3'h3;
              end
              ((~mt_wire) & (~fl_wire)) : begin
                  nextState = 3'h4;
              end
              default : begin
                  nextState = currentState;
              end
          endcase

      end
      3'h5 : begin
          red = 1'h1;
          amber = 1'h1;
          green = 1'h0;
          entimer = 1'h0;
          unique case (1'h1) 
              ped : begin
                  nextState = 3'h6;
              end
              (~ped) : begin
                  nextState = 3'h5;
              end
              default : begin
                  nextState = currentState;
              end
          endcase

      end
      3'h6 : begin
          red = 1'h1;
          amber = 1'h0;
          green = 1'h1;
          entimer = 1'h1;
          unique case (1'h1) 
              st_wire : begin
                  nextState = 3'h0;
              end
              (~st_wire) : begin
                  nextState = 3'h6;
              end
              default : begin
                  nextState = currentState;
              end
          endcase

      end
      default : begin
          nextState = currentState;
      end
  endcase

end

//  sequential
always_ff @(posedge clock) begin
  if(reset) begin
      currentState <= 3'h0;
  end else begin
      currentState <= nextState;
  end 

end

endmodule : Pelcont

////////////////////

module Pelican(
input logic clk,
input logic ped,
input logic reset,
output logic red,
output logic amber,
output logic green
);
logic mt_wire;
logic lt_wire;
logic fl_wire;
logic start;
logic lt;
Pelcont  pelcont_fsm(.clock(clk),.reset(reset),.ped(ped),.st_wire(lt_wire),.mt_wire(mt_wire),.lt_wire(lt_wire),.fl_wire(fl_wire),.red(red),.amber(amber),.green(green),.entimer(start));
Timer  timer(.start(start),.clk(clk),.st(lt_wire),.mt(mt_wire),.lt(lt));
FRTimer  timer_fr(.reset(reset),.clk(clk),.fr(fl_wire));
endmodule : Pelican